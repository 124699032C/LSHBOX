<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>lshbox by RSIA-LIESMARS-WHU</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">lshbox</h1>
      <h2 class="project-tagline">A c++ toolbox of locality-sensitive hashing (LSH), provides several popular LSH algorithms, also support python and matlab.</h2>
      <a href="https://github.com/RSIA-LIESMARS-WHU/LSHBOX" class="btn">View on GitHub</a>
      <a href="https://github.com/RSIA-LIESMARS-WHU/LSHBOX/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/RSIA-LIESMARS-WHU/LSHBOX/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h4>
<a id="change-log" class="anchor" href="#change-log" aria-hidden="true"><span class="octicon octicon-link"></span></a>Change Log</h4>

<p>A new LSH method, Double-Bit Quantization Hashing (DBQ), was added into LSHBOX-0.9 on June 4th, 2015. We implement DBQ by C++ but also provide MATLAB interface. And the Python interface will be added into LSHBOX-0.9 later. Other files related to DBQ have been updated synchronously.</p>

<h3>
<a id="chapter-1---introduction" class="anchor" href="#chapter-1---introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 1 - Introduction</h3>

<p>Locality-Sensitive Hashing (LSH) is an efficient method for large scale image retrieval, and it achieves great performance in approximate nearest neighborhood searching.</p>

<p>LSHBOX is a simple but robust C++ toolbox that provides several LSH algrithms, in addition, it can be integrated into Python and MATLAB languages. The following LSH algrithms have been implemented in LSHBOX, they are:</p>

<ul>
<li>Double-Bit Quantization Hashing</li>
<li>
<a href="http://www.cs.huji.ac.il/%7Eyweiss/SpectralHashing/">Spectral Hashing</a> (SH)</li>
<li>
<a href="http://www.unc.edu/%7Eyunchao/itq.htm">Iterative Quantization</a> (ITQ)</li>
<li>Random Hyperplane Hashing</li>
<li>LSH Based on Random Bits Sampling</li>
<li>LSH Based on Thresholding</li>
<li>LSH Based on p-Stable Distributions</li>
</ul>

<p>There are two repositories for compilation and performance tests, they are:</p>

<ul>
<li>
<a href="https://github.com/RSIA-LIESMARS-WHU/LSHBOX-3rdparty">LSHBOX-3rdparty</a>: 3rdparty of LSHBOX, it is for compilation</li>
<li>
<a href="https://github.com/RSIA-LIESMARS-WHU/LSHBOX-sample-data">LSHBOX-sample datasets</a>: datasets for performance tests</li>
</ul>

<p>Part of the code depends on the C++11, So I think your compiler should support this feature. We tested LSHBOX with VS2010 in Windows 7/8 32bit/64bit and with g++ in Linux, Mac test will be done in the next weeks. We hope that there are more people that join in the test or contribute more algrithms.</p>

<h5>
<a id="please-feel-free-to-contact-us-tanggefuqqcom-20288lysinacn-or-xiaozfgmailcom-if-you-have-any-questions" class="anchor" href="#please-feel-free-to-contact-us-tanggefuqqcom-20288lysinacn-or-xiaozfgmailcom-if-you-have-any-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Please feel free to contact us [<a href="mailto:tanggefu@qq.com">tanggefu@qq.com</a>, <a href="mailto:20288ly@sina.cn">20288ly@sina.cn</a> or <a href="mailto:xiaozf@gmail.com">xiaozf@gmail.com</a>] if you have any questions.</h5>

<h3>
<a id="chapter-2---compilation" class="anchor" href="#chapter-2---compilation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 2 - Compilation</h3>

<p>LSHBOX is written by C++. And it also can be easily used in many contexts through the Python and MATLAB bindings provided with this toolbox.</p>

<p>LSHBOX is simple and easy to use. If you want to integrate LSHBOX into you application, it don't need compile. You only need to add the include directory or modify the program search path, then you can use this library directly in C, C++, Python or MATLAB.</p>

<p>If you want to test or contribute, <a href="http://www.cmake.org">CMAKE</a>, a cross-platform, open-source build system, is usded to build some tools for the purpose. CMake can be downloaded from <a href="http://www.cmake.org/cmake/resources/software.html">CMake' website</a>.</p>

<p>In some cases, if you want or need to compile it by yourself with Python and MATLAB, please delete the comment of the last two lines in file <code>CMakeLists.txt</code>, and you will find the compiling progress of python must rely on Boost library or some part of this library. For more detailed information, you can view the document <code>./python/README</code>.</p>

<p>During compilation, create a new directory named <code>build</code> in the main directory, then choose a appropriate compiler and switch to the <code>build</code> directory, finally, execute the following command according to your machine:</p>

<ul>
<li>Windows</li>
</ul>

<div class="highlight highlight-cpp"><pre>cmake -DCMAKE_BUILD_TYPE=Release .. -G<span class="pl-s"><span class="pl-pds">"</span>NMake Makefiles<span class="pl-pds">"</span></span>
nmake</pre></div>

<ul>
<li>Linux</li>
</ul>

<div class="highlight highlight-cpp"><pre>cmake ..
make</pre></div>

<h3>
<a id="chapter-3---usage" class="anchor" href="#chapter-3---usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 3 - Usage</h3>

<p>This chapter contains small examples of how to use the LSHBOX library from different programming languages (C++, Python and MATLAB).</p>

<h5>
<a id="for-c" class="anchor" href="#for-c" aria-hidden="true"><span class="octicon octicon-link"></span></a>For C++</h5>

<div class="highlight highlight-cpp"><pre><span class="pl-c">/**</span>
<span class="pl-c"> * @file itqlsh_test.cpp</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * @brief Example of using Iterative Quantization for L2 distance.</span>
<span class="pl-c"> */</span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>lshbox.h<span class="pl-pds">&gt;</span></span>
<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span> <span class="pl-k">const</span> *argv[])
{
    <span class="pl-k">typedef</span> <span class="pl-k">float</span> DATATYPE;
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>LOADING DATA ...<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
    lshbox::timer timer;
    lshbox::Matrix&lt;DATATYPE&gt; <span class="pl-c1">data</span>(<span class="pl-s"><span class="pl-pds">"</span>audio.data<span class="pl-pds">"</span></span>);
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>LOAD TIME: <span class="pl-pds">"</span></span> &lt;&lt; timer.<span class="pl-c1">elapsed</span>() &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>s.<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>CONSTRUCTING INDEX ...<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
    timer.<span class="pl-c1">restart</span>();
    std::string file = <span class="pl-s"><span class="pl-pds">"</span>itq.lsh<span class="pl-pds">"</span></span>;
    <span class="pl-k">bool</span> use_index = <span class="pl-c1">false</span>;
    lshbox::itqLsh&lt;DATATYPE&gt; mylsh;
    <span class="pl-k">if</span> (use_index)
    {
        mylsh.<span class="pl-c1">load</span>(file);
    }
    <span class="pl-k">else</span>
    {
        lshbox::itqLsh&lt;DATATYPE&gt;::Parameter param;
        param.<span class="pl-smi">M</span> = <span class="pl-c1">521</span>;
        param.<span class="pl-smi">L</span> = <span class="pl-c1">5</span>;
        param.<span class="pl-smi">D</span> = data.<span class="pl-c1">getDim</span>();
        param.<span class="pl-smi">N</span> = <span class="pl-c1">8</span>;
        param.<span class="pl-smi">S</span> = <span class="pl-c1">100</span>;
        param.<span class="pl-smi">I</span> = <span class="pl-c1">50</span>;
        mylsh.<span class="pl-c1">reset</span>(param);
        mylsh.<span class="pl-c1">train</span>(data);
    }
    mylsh.<span class="pl-c1">save</span>(file);
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>CONSTRUCTING TIME: <span class="pl-pds">"</span></span> &lt;&lt; timer.<span class="pl-c1">elapsed</span>() &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>s.<span class="pl-pds">"</span></span>;
    std::cout &lt;&lt; std::endl &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>LOADING BENCHMARK ...<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
    timer.<span class="pl-c1">restart</span>();
    lshbox::Matrix&lt;DATATYPE&gt;::Accessor <span class="pl-smi">accessor</span>(data);
    lshbox::Metric&lt;DATATYPE&gt; <span class="pl-c1">metric</span>(data.<span class="pl-c1">getDim</span>(), L1_DIST);
    <span class="pl-k">unsigned</span> K = <span class="pl-c1">10</span>;
    <span class="pl-k">unsigned</span> Q = <span class="pl-c1">10</span>;
    lshbox::Scanner&lt;lshbox::Matrix&lt;DATATYPE&gt;::Accessor&gt; <span class="pl-c1">scanner</span>(
        accessor,
        metric,
        K,
        std::numeric_limits&lt;<span class="pl-k">float</span>&gt;::<span class="pl-c1">max</span>()
    );
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>LOADING TIME: <span class="pl-pds">"</span></span> &lt;&lt; timer.<span class="pl-c1">elapsed</span>() &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>s.<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>RUNING QUERY ...<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> I = <span class="pl-c1">0</span>; i != Q; ++i)
    {
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>----- QUERY <span class="pl-pds">"</span></span> &lt;&lt; i+<span class="pl-c1">1</span>  &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span> -----<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
        scanner.<span class="pl-c1">reset</span>(data[i]);
        mylsh.<span class="pl-c1">query</span>(data[i], scanner);
        std::vector&lt;std::pair&lt;<span class="pl-k">unsigned</span>, <span class="pl-k">float</span>&gt; &gt; result;
        result = scanner.<span class="pl-c1">topk</span>().<span class="pl-c1">getTopk</span>();
        <span class="pl-k">for</span> (<span class="pl-k">auto</span> it = result.<span class="pl-c1">begin</span>(); it != result.<span class="pl-c1">end</span>(); ++it)
        {
            std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Frequency : <span class="pl-pds">"</span></span> &lt;&lt; scanner.<span class="pl-c1">cnt</span>() &lt;&lt; std::endl;
    }
}</pre></div>

<p>You can get the sample dataset <code>audio.data</code> from <a href="http://www.cs.princeton.edu/cass/audio.tar.gz">http://www.cs.princeton.edu/cass/audio.tar.gz</a>, if the link is invalid, you can also get it from <a href="https://github.com/RSIA-LIESMARS-WHU/LSHBOX-sample-data">LSHBOX-sample-data</a>.</p>

<h5>
<a id="for-python" class="anchor" href="#for-python" aria-hidden="true"><span class="octicon octicon-link"></span></a>For Python</h5>

<p>(NOTE: In Windows, the py module name is pylshbox, but in linux, it will be libpylshbox.)</p>

<div class="highlight highlight-python"><pre><span class="pl-c">#!/usr/bin/env python</span>
<span class="pl-c"># -*- coding: utf-8 -*-</span>
<span class="pl-c"># pylshbox_example.py</span>
<span class="pl-k">import</span> pylshbox
<span class="pl-k">import</span> numpy
<span class="pl-c"># prepare test data</span>
float_mat <span class="pl-k">=</span> numpy.random.rand(<span class="pl-c1">100000</span>, <span class="pl-c1">192</span>)
float_query <span class="pl-k">=</span> float_mat[<span class="pl-c1">1</span>,:]
unsigned_mat <span class="pl-k">=</span> numpy.int32(float_mat<span class="pl-k">*</span><span class="pl-c1">5</span>)
unsigned_query <span class="pl-k">=</span> unsigned_mat[<span class="pl-c1">1</span>,:]
<span class="pl-c"># Test rbsLsh</span>
rbs_mat <span class="pl-k">=</span> pylshbox.rbslsh()
rbs_mat.init_mat(unsigned_mat.tolist(), <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">20</span>, <span class="pl-c1">5</span>)
result <span class="pl-k">=</span> rbs_mat.query(unsigned_query.tolist(), <span class="pl-c1">1</span>)
indices, dists <span class="pl-k">=</span> result[<span class="pl-c1">0</span>],result[<span class="pl-c1">1</span>]
<span class="pl-c"># Test rhpLsh</span>
rhp_mat <span class="pl-k">=</span> pylshbox.rhplsh()
rhp_mat.init_mat(float_mat.tolist(), <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>)
result <span class="pl-k">=</span> rhp_mat.query(float_query.tolist(), <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
indices, dists <span class="pl-k">=</span> result[<span class="pl-c1">0</span>],result[<span class="pl-c1">1</span>]
<span class="pl-c"># Test thLsh</span>
th_mat <span class="pl-k">=</span> pylshbox.thlsh()
th_mat.init_mat(float_mat.tolist(), <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">12</span>)
result <span class="pl-k">=</span> th_mat.query(float_query.tolist(), <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
indices, dists <span class="pl-k">=</span> result[<span class="pl-c1">0</span>],result[<span class="pl-c1">1</span>]
<span class="pl-c"># Test psdlsh with param.T = 1</span>
psdL1_mat <span class="pl-k">=</span> pylshbox.psdlsh()
psdL1_mat.init_mat(float_mat.tolist(), <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">1</span>, <span class="pl-c1">5</span>)
result <span class="pl-k">=</span> psdL1_mat.query(float_query.tolist(), <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
indices, dists <span class="pl-k">=</span> result[<span class="pl-c1">0</span>],result[<span class="pl-c1">1</span>]
<span class="pl-c"># Test psdlsh with param.T = 2</span>
psdL2_mat <span class="pl-k">=</span> pylshbox.psdlsh()
psdL2_mat.init_mat(float_mat.tolist(), <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">2</span>, <span class="pl-c1">0.5</span>)
result <span class="pl-k">=</span> psdL2_mat.query(float_query.tolist(), <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
indices, dists <span class="pl-k">=</span> result[<span class="pl-c1">0</span>],result[<span class="pl-c1">1</span>]
<span class="pl-c"># Test shLsh</span>
sh_mat <span class="pl-k">=</span> pylshbox.shlsh()
sh_mat.init_mat(float_mat.tolist(), <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">4</span>, <span class="pl-c1">100</span>)
result <span class="pl-k">=</span> sh_mat.query(float_query.tolist(), <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
indices, dists <span class="pl-k">=</span> result[<span class="pl-c1">0</span>],result[<span class="pl-c1">1</span>]
<span class="pl-c"># Test itqLsh</span>
itq_mat <span class="pl-k">=</span> pylshbox.itqlsh()
itq_mat.init_mat(float_mat.tolist(), <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">8</span>, <span class="pl-c1">100</span>, <span class="pl-c1">50</span>)
result <span class="pl-k">=</span> itq_mat.query(float_query.tolist(), <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
indices, dists <span class="pl-k">=</span> result[<span class="pl-c1">0</span>],result[<span class="pl-c1">1</span>]</pre></div>

<h5>
<a id="for-matlab" class="anchor" href="#for-matlab" aria-hidden="true"><span class="octicon octicon-link"></span></a>For MATLAB</h5>

<div class="highlight highlight-matlab"><pre><span class="pl-c">% lshbox_example.m</span>
<span class="pl-c">% prepare test data</span>
<span class="pl-c1">dataset</span> = <span class="pl-k">rand</span>(<span class="pl-c1">128</span>,<span class="pl-c1">100000</span>);
testset = <span class="pl-c1">dataset</span>(<span class="pl-k">:</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>);
<span class="pl-c">% Test rhplsh</span>
param_rhp.M = <span class="pl-c1">521</span>;
param_rhp.L = <span class="pl-c1">5</span>;
param_rhp.N = <span class="pl-c1">6</span>;
[indices, dists] = rhplsh(<span class="pl-c1">dataset</span>, testset, param_rhp, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
<span class="pl-c">% Test thlsh</span>
param_th.M = <span class="pl-c1">521</span>;
param_th.L = <span class="pl-c1">5</span>;
param_th.N = <span class="pl-c1">12</span>;
[indices, dists] = thlsh(<span class="pl-c1">dataset</span>, testset, param_th, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
<span class="pl-c">% Test psdlsh with param_psdL1.T = 1</span>
param_psdL1.M = <span class="pl-c1">521</span>;
param_psdL1.L = <span class="pl-c1">5</span>;
param_psdL1.T = <span class="pl-c1">1</span>;
param_psdL1.W = <span class="pl-c1">5</span>;
[indices, dists] = psdlsh(<span class="pl-c1">dataset</span>, testset, param_psdL1, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">1</span>, <span class="pl-c1">10</span>)
<span class="pl-c">% Test psdlsh with param_psdL2.T = 2</span>
param_psdL2.M = <span class="pl-c1">521</span>;
param_psdL2.L = <span class="pl-c1">5</span>;
param_psdL2.T = <span class="pl-c1">2</span>;
param_psdL2.W = <span class="pl-c1">0.5</span>;
[indices, dists] = psdlsh(<span class="pl-c1">dataset</span>, testset, param_psdL2, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
<span class="pl-c">% Test shlsh</span>
param_sh.M = <span class="pl-c1">521</span>;
param_sh.L = <span class="pl-c1">5</span>;
param_sh.N = <span class="pl-c1">4</span>;
param_sh.S = <span class="pl-c1">100</span>;
[indices, dists] = shlsh(<span class="pl-c1">dataset</span>, testset, param_sh, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
<span class="pl-c">% Test itqlsh</span>
param_itq.M = <span class="pl-c1">521</span>;
param_itq.L = <span class="pl-c1">5</span>;
param_itq.N = <span class="pl-c1">8</span>;
param_itq.S = <span class="pl-c1">100</span>;
param_itq.I = <span class="pl-c1">50</span>;
[indices, dists] = itqlsh(<span class="pl-c1">dataset</span>, testset, param_itq, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
<span class="pl-c">% Test dbqlsh</span>
param_dbq.M = <span class="pl-c1">521</span>;
param_dbq.L = <span class="pl-c1">5</span>;
param_dbq.N = <span class="pl-c1">4</span>;
param_dbq.I = <span class="pl-c1">5</span>;
[indices, dists] = dbqlsh(<span class="pl-c1">dataset</span>, testset, param_itq, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)</pre></div>

<p>Have you ever find the empty string used in the Python and MATLAB code? In fact, they can be used to save the index through pass a file name. Like the following, you will find the next query speed faster than the first, because there is no re-indexing.</p>

<h5>
<a id="for-python-1" class="anchor" href="#for-python-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>For Python</h5>

<div class="highlight highlight-python"><pre><span class="pl-c">#!/usr/bin/env python</span>
<span class="pl-c"># -*- coding: utf-8 -*-</span>
<span class="pl-c"># pylshbox_example2.py</span>
<span class="pl-k">import</span> pylshbox
<span class="pl-k">import</span> numpy
<span class="pl-k">import</span> time
<span class="pl-c"># prepare test data</span>
float_file <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>audio.data<span class="pl-pds">'</span></span>
float_query <span class="pl-k">=</span> numpy.random.rand(<span class="pl-c1">192</span>)
<span class="pl-c"># Test itqLsh</span>
<span class="pl-c"># First time, need to constructing index. About 1.5s.</span>
start <span class="pl-k">=</span> time.time()
itq_file <span class="pl-k">=</span> pylshbox.itqlsh()
itq_file.init_file(float_file, <span class="pl-s"><span class="pl-pds">'</span>pyitq.lsh<span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">8</span>, <span class="pl-c1">100</span>, <span class="pl-c1">50</span>)
result <span class="pl-k">=</span> itq_file.query(float_query.tolist(), <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
<span class="pl-k">print</span> <span class="pl-s"><span class="pl-pds">'</span>Elapsed time is <span class="pl-c1">%f</span> seconds.<span class="pl-pds">'</span></span> <span class="pl-k">%</span> (time.time() <span class="pl-k">-</span> start)
<span class="pl-c"># Second time, no need to re-indexing. About 0.05s.</span>
start <span class="pl-k">=</span> time.time()
itq_file2 <span class="pl-k">=</span> pylshbox.itqlsh()
itq_file2.init_file(float_file, <span class="pl-s"><span class="pl-pds">'</span>pyitq.lsh<span class="pl-pds">'</span></span>, <span class="pl-c1">521</span>, <span class="pl-c1">5</span>, <span class="pl-c1">8</span>, <span class="pl-c1">100</span>, <span class="pl-c1">50</span>)
result <span class="pl-k">=</span> itq_file2.query(float_query.tolist(), <span class="pl-c1">2</span>, <span class="pl-c1">10</span>)
<span class="pl-k">print</span> <span class="pl-s"><span class="pl-pds">'</span>Elapsed time is <span class="pl-c1">%f</span> seconds.<span class="pl-pds">'</span></span> <span class="pl-k">%</span> (time.time() <span class="pl-k">-</span> start)</pre></div>

<h5>
<a id="for-matlab-1" class="anchor" href="#for-matlab-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>For MATLAB</h5>

<div class="highlight highlight-matlab"><pre><span class="pl-c">% lshbox_example2.m</span>
<span class="pl-c">% prepare test data</span>
<span class="pl-c1">dataset</span> = <span class="pl-k">rand</span>(<span class="pl-c1">128</span>,<span class="pl-c1">500000</span>);
testset = <span class="pl-c1">dataset</span>(<span class="pl-k">:</span>,<span class="pl-c1">1</span><span class="pl-k">:</span><span class="pl-c1">10</span>);
<span class="pl-c">% Test itqlsh</span>
param_itq.M = <span class="pl-c1">521</span>;
param_itq.L = <span class="pl-c1">5</span>;
param_itq.N = <span class="pl-c1">8</span>;
param_itq.S = <span class="pl-c1">100</span>;
param_itq.I = <span class="pl-c1">50</span>;
<span class="pl-c">% First time, need to constructing index. About 10s.</span>
<span class="pl-k">tic</span>;
[indices, dists] = itqlsh(<span class="pl-c1">dataset</span>, testset, param_itq, <span class="pl-s"><span class="pl-pds">'</span>itq.lsh<span class="pl-pds">'</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>);
<span class="pl-k">toc</span>;
<span class="pl-c">% Second time, no need to re-indexing. About 2s.</span>
<span class="pl-k">tic</span>;
[indices, dists] = itqlsh(<span class="pl-c1">dataset</span>, testset, param_itq, <span class="pl-s"><span class="pl-pds">'</span>itq.lsh<span class="pl-pds">'</span></span>, <span class="pl-c1">2</span>, <span class="pl-c1">10</span>);
<span class="pl-k">toc</span>;</pre></div>

<h3>
<a id="chapter-4---algorithm" class="anchor" href="#chapter-4---algorithm" aria-hidden="true"><span class="octicon octicon-link"></span></a>Chapter 4 - Algorithm</h3>

<p>LSHBOX is based on many approximate nearest neighbor schemes, and the following is a brief description of each algorithm and its parameters.</p>

<h4>
<a id="41---locality-sensitive-hashing-scheme-based-on-random-bits-sampling" class="anchor" href="#41---locality-sensitive-hashing-scheme-based-on-random-bits-sampling" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.1 - Locality-Sensitive Hashing Scheme Based on Random Bits Sampling</h4>

<h5>
<a id="reference" class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h5>

<pre><code>P. Indyk and R. Motwani. Approximate Nearest Neighbor - Towards Removing the Curse of Dimensionality. In Proceedings of the 30th Symposium on Theory of Computing, 1998, pp. 604-613.

A. Gionis, P. Indyk, and R. Motwani. Similarity search in high dimensions via hashing. Proceedings of the 25th International Conference on Very Large Data Bases (VLDB), 1999.
</code></pre>

<h5>
<a id="parameters" class="anchor" href="#parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h5>

<div class="highlight highlight-cpp"><pre><span class="pl-k">struct</span> <span class="pl-en">Parameter</span>
{
    <span class="pl-c">/// Hash table size</span>
    <span class="pl-k">unsigned</span> M;
    <span class="pl-c">/// Number of hash tables</span>
    <span class="pl-k">unsigned</span> L;
    <span class="pl-c">/// Dimension of the vector</span>
    <span class="pl-k">unsigned</span> D;
    <span class="pl-c">/// Binary code bytes</span>
    <span class="pl-k">unsigned</span> N;
    <span class="pl-c">/// The Difference between upper and lower bound of each dimension</span>
    <span class="pl-k">unsigned</span> C;
};</pre></div>

<h5>
<a id="implementation" class="anchor" href="#implementation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h5>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>lshbox/rbslsh.h<span class="pl-pds">&gt;</span></span></pre></div>

<p>According to the second assumption in the paper, all coordinates of points in P are positive integer. Although we can convert all coordinates to integers by multiplying them by a suitably large number and rounding to the nearest integer, but I think it is very fussy, What's more, it often gets criticized for using too much memory when in a larger range of data. Therefore, it is recommended to use other algorithm.</p>

<h4>
<a id="42---locality-sensitive-hashing-scheme-based-on-random-hyperplane" class="anchor" href="#42---locality-sensitive-hashing-scheme-based-on-random-hyperplane" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.2 - Locality-Sensitive Hashing Scheme Based on Random Hyperplane</h4>

<h5>
<a id="reference-1" class="anchor" href="#reference-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h5>

<pre><code>Charikar, M. S. 2002. Similarity estimation techniques from rounding algorithms. In Proceedings of the Thiry-Fourth Annual ACM Symposium on theory of Computing (Montreal, Quebec, Canada, May 19 - 21, 2002). STOC '02. ACM, New York, NY, 380-388. DOI= http://doi.acm.org/10.1145/509907.509965
</code></pre>

<h5>
<a id="parameters-1" class="anchor" href="#parameters-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h5>

<div class="highlight highlight-cpp"><pre><span class="pl-k">struct</span> <span class="pl-en">Parameter</span>
{
    <span class="pl-c">/// Hash table size</span>
    <span class="pl-k">unsigned</span> M;
    <span class="pl-c">/// Number of hash tables</span>
    <span class="pl-k">unsigned</span> L;
    <span class="pl-c">/// Dimension of the vector</span>
    <span class="pl-k">unsigned</span> D;
    <span class="pl-c">/// Binary code bytes</span>
    <span class="pl-k">unsigned</span> N;
};</pre></div>

<h5>
<a id="implementation-1" class="anchor" href="#implementation-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h5>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>lshbox/rhplsh.h<span class="pl-pds">&gt;</span></span></pre></div>

<h4>
<a id="43---locality-sensitive-hashing-scheme-based-on-thresholding" class="anchor" href="#43---locality-sensitive-hashing-scheme-based-on-thresholding" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.3 - Locality-Sensitive Hashing Scheme Based on Thresholding</h4>

<h5>
<a id="reference-2" class="anchor" href="#reference-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h5>

<pre><code>Zhe Wang, Wei Dong, William Josephson, Qin Lv, Moses Charikar, Kai Li. Sizing Sketches: A Rank-Based Analysis for Similarity Search. In Proceedings of the 2007 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems . San Diego, CA, USA. June 2007.

Qin Lv, Moses Charikar, Kai Li. Image Similarity Search with Compact Data Structures. In Proceedings of ACM 13th Conference on Information and Knowledge Management (CIKM), Washington D.C., USA. November 2004.
</code></pre>

<h5>
<a id="parameters-2" class="anchor" href="#parameters-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h5>

<div class="highlight highlight-cpp"><pre><span class="pl-k">struct</span> <span class="pl-en">Parameter</span>
{
    <span class="pl-c">/// Hash table size</span>
    <span class="pl-k">unsigned</span> M;
    <span class="pl-c">/// Number of hash tables</span>
    <span class="pl-k">unsigned</span> L;
    <span class="pl-c">/// Dimension of the vector</span>
    <span class="pl-k">unsigned</span> D;
    <span class="pl-c">/// Binary code bytes</span>
    <span class="pl-k">unsigned</span> N;
    <span class="pl-c">/// Upper bound of each dimension</span>
    <span class="pl-k">float</span> Max;
    <span class="pl-c">/// Lower bound of each dimension</span>
    <span class="pl-k">float</span> Min;
};</pre></div>

<h5>
<a id="implementation-2" class="anchor" href="#implementation-2" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h5>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>lshbox/thlsh.h<span class="pl-pds">&gt;</span></span></pre></div>

<h4>
<a id="44---locality-sensitive-hashing-scheme-based-on-p-stable-distributions" class="anchor" href="#44---locality-sensitive-hashing-scheme-based-on-p-stable-distributions" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.4 - Locality-Sensitive Hashing Scheme Based on p-Stable Distributions</h4>

<h5>
<a id="reference-3" class="anchor" href="#reference-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h5>

<pre><code>Mayur Datar , Nicole Immorlica , Piotr Indyk , Vahab S. Mirrokni, Locality-sensitive hashing scheme based on p-stable distributions, Proceedings of the twentieth annual symposium on Computational geometry, June 08-11, 2004, Brooklyn, New York, USA.
</code></pre>

<h5>
<a id="parameters-3" class="anchor" href="#parameters-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h5>

<div class="highlight highlight-cpp"><pre><span class="pl-k">struct</span> <span class="pl-en">Parameter</span>
{
    <span class="pl-c">/// Hash table size</span>
    <span class="pl-k">unsigned</span> M;
    <span class="pl-c">/// Number of hash tables</span>
    <span class="pl-k">unsigned</span> L;
    <span class="pl-c">/// Dimension of the vector</span>
    <span class="pl-k">unsigned</span> D;
    <span class="pl-c">/// Index mode, you can choose 1(CAUCHY) or 2(GAUSSIAN)</span>
    <span class="pl-k">unsigned</span> T;
    <span class="pl-c">/// Window size</span>
    <span class="pl-k">float</span> W;
};</pre></div>

<h5>
<a id="implementation-3" class="anchor" href="#implementation-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h5>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>lshbox/psdlsh.h<span class="pl-pds">&gt;</span></span></pre></div>

<h4>
<a id="45---spectral-hashing" class="anchor" href="#45---spectral-hashing" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.5 - Spectral Hashing</h4>

<h5>
<a id="reference-4" class="anchor" href="#reference-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h5>

<pre><code>Y. Weiss, A. Torralba, R. Fergus. Spectral Hashing. Advances in Neural Information Processing Systems, 2008.
</code></pre>

<h5>
<a id="parameters-4" class="anchor" href="#parameters-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h5>

<div class="highlight highlight-cpp"><pre><span class="pl-k">struct</span> <span class="pl-en">Parameter</span>
{
    <span class="pl-c">/// Hash table size</span>
    <span class="pl-k">unsigned</span> M;
    <span class="pl-c">/// Number of hash tables</span>
    <span class="pl-k">unsigned</span> L;
    <span class="pl-c">/// Dimension of the vector</span>
    <span class="pl-k">unsigned</span> D;
    <span class="pl-c">/// Binary code bytes</span>
    <span class="pl-k">unsigned</span> N;
    <span class="pl-c">/// Size of vectors in train</span>
    <span class="pl-k">unsigned</span> S;
};</pre></div>

<h5>
<a id="implementation-4" class="anchor" href="#implementation-4" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h5>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>lshbox/shlsh.h<span class="pl-pds">&gt;</span></span></pre></div>

<h4>
<a id="46---iterative-quantization" class="anchor" href="#46---iterative-quantization" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.6 - Iterative Quantization</h4>

<h5>
<a id="reference-5" class="anchor" href="#reference-5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h5>

<pre><code>Gong Y, Lazebnik S, Gordo A, et al. Iterative quantization: A procrustean approach to learning binary codes for large-scale image retrieval[J]. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 2013, 35(12): 2916-2929.
</code></pre>

<h5>
<a id="parameters-5" class="anchor" href="#parameters-5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h5>

<div class="highlight highlight-cpp"><pre><span class="pl-k">struct</span> <span class="pl-en">Parameter</span>
{
    <span class="pl-c">/// Hash table size</span>
    <span class="pl-k">unsigned</span> M;
    <span class="pl-c">/// Number of hash tables</span>
    <span class="pl-k">unsigned</span> L;
    <span class="pl-c">/// Dimension of the vector</span>
    <span class="pl-k">unsigned</span> D;
    <span class="pl-c">/// Binary code bytes</span>
    <span class="pl-k">unsigned</span> N;
    <span class="pl-c">/// Size of vectors in train</span>
    <span class="pl-k">unsigned</span> S;
    <span class="pl-c">/// Training iterations</span>
    <span class="pl-k">unsigned</span> I;
};</pre></div>

<h5>
<a id="implementation-5" class="anchor" href="#implementation-5" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h5>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>lshbox/itqlsh.h<span class="pl-pds">&gt;</span></span></pre></div>

<h3>
<a id="47---double-bit-quantization-hashing" class="anchor" href="#47---double-bit-quantization-hashing" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.7 - Double-Bit Quantization Hashing</h3>

<h5>
<a id="reference-6" class="anchor" href="#reference-6" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h5>

<pre><code>Kong W, Li W. Double-Bit Quantization for Hashing. In AAAI, 2012.

Gong Y, Lazebnik S, Gordo A, et al. Iterative quantization: A procrustean approach to learning binary codes for large-scale image retrieval[J]. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 2013, 35(12): 2916-2929.
</code></pre>

<h5>
<a id="parameters-6" class="anchor" href="#parameters-6" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parameters</h5>

<div class="highlight highlight-cpp"><pre><span class="pl-k">struct</span> <span class="pl-en">Parameter</span>
{
    <span class="pl-c">/// Hash table size</span>
    <span class="pl-k">unsigned</span> M;
    <span class="pl-c">/// Number of hash tables</span>
    <span class="pl-k">unsigned</span> L;
    <span class="pl-c">/// Dimension of the vector</span>
    <span class="pl-k">unsigned</span> D;
    <span class="pl-c">/// Number of projection dimensions,corresponding to 2*N binary code bytes for each vector</span>
    <span class="pl-k">unsigned</span> N;
    <span class="pl-c">/// Training iterations</span>
    <span class="pl-k">unsigned</span> I;
};</pre></div>

<h5>
<a id="implementation-6" class="anchor" href="#implementation-6" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h5>

<div class="highlight highlight-cpp"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>lshbox/dbqlsh.h<span class="pl-pds">&gt;</span></span></pre></div>

<p>According to the test, Double-Bit Quantization Hashing and Iterative Quantization performance very good and are superior to other schemes. Iterative Quantization can get high query accuracy with minimum cost while Double-Bit Quantization Hashing can achieve better query accuracy.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/RSIA-LIESMARS-WHU/LSHBOX">lshbox</a> is maintained by <a href="https://github.com/RSIA-LIESMARS-WHU">RSIA-LIESMARS-WHU</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("lshbox, lsh");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>

