{"name":"lshbox","tagline":"A c++ toolbox of locality-sensitive hashing (LSH), provides several popular LSH algorithms, also support python and matlab.","body":"###Chapter 1 - Introduce\r\n\r\nLocality-Sensitive Hashing (LSH) is an efficient method for large scale image retrieval, and it achieves great performance in approximate nearest neighborhood searching.\r\n\r\nLSHBOX is a simple but robust C++ toolbox that provides several LSH algrithms, in addition, it can be integrated into Python and MATLAB languages. The following LSH algrithms have been implemented in LSHBOX, they are:\r\n\r\n* [Spectral Hashing](http://www.cs.huji.ac.il/~yweiss/SpectralHashing/) (SH)\r\n* [Iterative Quantization](http://www.unc.edu/~yunchao/itq.htm) (ITQ)\r\n* Random Hyperplane Hashing\r\n* LSH Based on Random Bits Sampling\r\n* LSH Based on Thresholding\r\n* LSH Based on p-Stable Distributions\r\n\r\nThere are two repositories for compilation and performance tests, they are:\r\n* [LSHBOX-3rdparty](https://github.com/RSIA-LIESMARS-WHU/LSHBOX-3rdparty): 3rdparty of LSHBOX, it is for compilation\r\n* [LSHBOX-sample datasets](https://github.com/RSIA-LIESMARS-WHU/LSHBOX-sample-data): datasets for performance tests\r\n\r\nPart of the code depends on the C++11, So I think your compiler should support this feature. We tested LSHBOX with VS2010 in Windows 7/8 32bit/64bit, Mac and Linux test will be done in the next weeks. We hope that there are more people that join in the test or contribute more algrithms.\r\n\r\nPlease feel free to contact us [tanggefu@gmail.com or xiaozf@gmail.com] if you have any questions.\r\n\r\n###Chapter 2 - Compilation\r\n\r\nLSHBOX is written by C++. And it also can be easily used in many contexts through the Python and MATLAB bindings provided with this toolbox.\r\n\r\nLSHBOX is simple and easy to use. If you want to integrate LSHBOX into you application, it don't need compile. You only need to add the include directory or modify the program search path, then you can use this library directly in C, C++, Python or MATLAB.\r\n\r\nIf you want to test or contribute, [CMAKE](http://www.cmake.org), a cross-platform, open-source build system, is usded to build some tools for the purpose. CMake can be downloaded from [CMake' website](http://www.cmake.org/cmake/resources/software.html).\r\n\r\nIn some cases, if you want or need to compile it by yourself with Python and MATLAB, please delete the comment of the last two lines in file `CMakeLists.txt`, and you will find the compiling progress of python must rely on Boost library or some part of this library. For more detailed information, you can view the document `./python/README`.\r\n\r\nDuring compilation, create a new directory named `build` in the main directory, then choose a appropriate compiler and switch to the `build` directory, finally, execute the following command according to your machine:\r\n\r\n* Windows\r\n\r\n```cpp\r\ncmake -DCMAKE_BUILD_TYPE=Release .. -G\"NMake Makefiles\"\r\nnmake\r\n```\r\n\r\n* Linux\r\n\r\n```cpp\r\ncmake ..\r\nmake\r\n```\r\n\r\n###Chapter 3 - Usage\r\n\r\nThis chapter contains small examples of how to use the LSHBOX library from different programming languages (C++, Python and MATLAB).\r\n\r\n#####For C++\r\n\r\n```cpp\r\n/**\r\n * @file itqlsh_test.cpp\r\n *\r\n * @brief Example of using Iterative Quantization for L2 distance.\r\n */\r\n#include <lshbox.h>\r\nint main(int argc, char const *argv[])\r\n{\r\n    typedef float DATATYPE;\r\n    std::cout << \"LOADING DATA ...\" << std::endl;\r\n    lshbox::timer timer;\r\n    lshbox::Matrix<DATATYPE> data(\"audio.data\");\r\n    std::cout << \"LOAD TIME: \" << timer.elapsed() << \"s.\" << std::endl;\r\n    std::cout << \"CONSTRUCTING INDEX ...\" << std::endl;\r\n    timer.restart();\r\n    std::string file = \"itq.lsh\";\r\n    bool use_index = false;\r\n    lshbox::itqLsh<DATATYPE> mylsh;\r\n    if (use_index)\r\n    {\r\n        mylsh.load(file);\r\n    }\r\n    else\r\n    {\r\n        lshbox::itqLsh<DATATYPE>::Parameter param;\r\n        param.M = 521;\r\n        param.L = 5;\r\n        param.D = data.getDim();\r\n        param.N = 8;\r\n        param.S = 100;\r\n        param.I = 50;\r\n        mylsh.reset(param);\r\n        mylsh.train(data);\r\n    }\r\n    mylsh.save(file);\r\n    std::cout << \"CONSTRUCTING TIME: \" << timer.elapsed() << \"s.\";\r\n    std::cout << std::endl << \"LOADING BENCHMARK ...\" << std::endl;\r\n    timer.restart();\r\n    lshbox::Matrix<DATATYPE>::Accessor accessor(data);\r\n    lshbox::Metric<DATATYPE> metric(data.getDim(), L1_DIST);\r\n    unsigned K = 10;\r\n    unsigned Q = 10;\r\n    lshbox::Scanner<lshbox::Matrix<DATATYPE>::Accessor> scanner(\r\n        accessor,\r\n        metric,\r\n        K,\r\n        std::numeric_limits<float>::max()\r\n    );\r\n    std::cout << \"LOADING TIME: \" << timer.elapsed() << \"s.\" << std::endl;\r\n    std::cout << \"RUNING QUERY ...\" << std::endl;\r\n    for (int I = 0; i != Q; ++i)\r\n    {\r\n        std::cout << \"----- QUERY \" << i+1  << \" -----\" << std::endl;\r\n        scanner.reset(data[i]);\r\n        mylsh.query(data[i], scanner);\r\n        std::vector<std::pair<unsigned, float> > result;\r\n        result = scanner.topk().getTopk();\r\n        for (auto it = result.begin(); it != result.end(); ++it)\r\n        {\r\n            std::cout << it->first << \", \" << it->second << std::endl;\r\n        }\r\n        std::cout << \"Frequency : \" << scanner.cnt() << std::endl;\r\n    }\r\n}\r\n```\r\nYou can get the sample dataset `audio.data` from [http://www.cs.princeton.edu/cass/audio.tar.gz](http://www.cs.princeton.edu/cass/audio.tar.gz), if the link is invalid, you can also get it from [LSHBOX-sample-data](https://github.com/RSIA-LIESMARS-WHU/LSHBOX-sample-data).\r\n\r\n#####For Python\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n# pylshbox_example.py\r\nimport pylshbox\r\nimport numpy\r\n# prepare test data\r\nfloat_mat = numpy.random.rand(100000, 192)\r\nfloat_query = float_mat[1,:]\r\nunsigned_mat = numpy.int32(float_mat*5)\r\nunsigned_query = unsigned_mat[1,:]\r\n# Test rbsLsh\r\nrbs_mat = pylshbox.rbslsh()\r\nrbs_mat.init_mat(unsigned_mat.tolist(), '', 521, 5, 20, 5)\r\nresult = rbs_mat.query(unsigned_query.tolist(), 1)\r\nindices, dists = result[0],result[1]\r\n# Test rhpLsh\r\nrhp_mat = pylshbox.rhplsh()\r\nrhp_mat.init_mat(float_mat.tolist(), '', 521, 5, 6)\r\nresult = rhp_mat.query(float_query.tolist(), 2, 10)\r\nindices, dists = result[0],result[1]\r\n# Test thLsh\r\nth_mat = pylshbox.thlsh()\r\nth_mat.init_mat(float_mat.tolist(), '', 521, 5, 12)\r\nresult = th_mat.query(float_query.tolist(), 2, 10)\r\nindices, dists = result[0],result[1]\r\n# Test psdlsh with param.T = 1\r\npsdL1_mat = pylshbox.psdlsh()\r\npsdL1_mat.init_mat(float_mat.tolist(), '', 521, 5, 1, 5)\r\nresult = psdL1_mat.query(float_query.tolist(), 2, 10)\r\nindices, dists = result[0],result[1]\r\n# Test psdlsh with param.T = 2\r\npsdL2_mat = pylshbox.psdlsh()\r\npsdL2_mat.init_mat(float_mat.tolist(), '', 521, 5, 2, 0.5)\r\nresult = psdL2_mat.query(float_query.tolist(), 2, 10)\r\nindices, dists = result[0],result[1]\r\n# Test shLsh\r\nsh_mat = pylshbox.shlsh()\r\nsh_mat.init_mat(float_mat.tolist(), '', 521, 5, 4, 100)\r\nresult = sh_mat.query(float_query.tolist(), 2, 10)\r\nindices, dists = result[0],result[1]\r\n# Test itqLsh\r\nitq_mat = pylshbox.itqlsh()\r\nitq_mat.init_mat(float_mat.tolist(), '', 521, 5, 8, 100, 50)\r\nresult = itq_mat.query(float_query.tolist(), 2, 10)\r\nindices, dists = result[0],result[1]\r\n```\r\n\r\n#####For MATLAB\r\n\r\n```matlab\r\n% lshbox_example.m\r\n% prepare test data\r\ndataset = rand(128,100000);\r\ntestset = dataset(:,1:10);\r\n% Test rhplsh\r\nparam_rhp.M = 521;\r\nparam_rhp.L = 5;\r\nparam_rhp.N = 6;\r\n[indices, dists] = rhplsh(dataset, testset, param_rhp, '', 2, 10)\r\n% Test thlsh\r\nparam_th.M = 521;\r\nparam_th.L = 5;\r\nparam_th.N = 12;\r\n[indices, dists] = thlsh(dataset, testset, param_th, '', 2, 10)\r\n% Test psdlsh with param_psdL1.T = 1\r\nparam_psdL1.M = 521;\r\nparam_psdL1.L = 5;\r\nparam_psdL1.T = 1;\r\nparam_psdL1.W = 5;\r\n[indices, dists] = psdlsh(dataset, testset, param_psdL1, '', 1, 10)\r\n% Test psdlsh with param_psdL2.T = 2\r\nparam_psdL2.M = 521;\r\nparam_psdL2.L = 5;\r\nparam_psdL2.T = 2;\r\nparam_psdL2.W = 0.5;\r\n[indices, dists] = psdlsh(dataset, testset, param_psdL2, '', 2, 10)\r\n% Test shlsh\r\nparam_sh.M = 521;\r\nparam_sh.L = 5;\r\nparam_sh.N = 4;\r\nparam_sh.S = 100;\r\n[indices, dists] = shlsh(dataset, testset, param_sh, '', 2, 10)\r\n% Test itqlsh\r\nparam_itq.M = 521;\r\nparam_itq.L = 5;\r\nparam_itq.N = 8;\r\nparam_itq.S = 100;\r\nparam_itq.I = 50;\r\n[indices, dists] = itqlsh(dataset, testset, param_itq, '', 2, 10)\r\n```\r\n\r\nHave you ever find the empty string used in the Python and MATLAB code? In fact, they can be used to save the index through pass a file name. Like the following, you will find the next query speed faster than the first, because there is no re-indexing.\r\n\r\n#####For Python\r\n\r\n```python\r\n#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n# pylshbox_example2.py\r\nimport pylshbox\r\nimport numpy\r\nimport time\r\n# prepare test data\r\nfloat_file = 'audio.data'\r\nfloat_query = numpy.random.rand(192)\r\n# Test itqLsh\r\n# First time, need to constructing index. About 1.5s.\r\nstart = time.time()\r\nitq_file = pylshbox.itqlsh()\r\nitq_file.init_file(float_file, 'pyitq.lsh', 521, 5, 8, 100, 50)\r\nresult = itq_file.query(float_query.tolist(), 2, 10)\r\nprint 'Elapsed time is %f seconds.' % (time.time() - start)\r\n# Second time, no need to re-indexing. About 0.05s.\r\nstart = time.time()\r\nitq_file2 = pylshbox.itqlsh()\r\nitq_file2.init_file(float_file, 'pyitq.lsh', 521, 5, 8, 100, 50)\r\nresult = itq_file2.query(float_query.tolist(), 2, 10)\r\nprint 'Elapsed time is %f seconds.' % (time.time() - start)\r\n```\r\n\r\n#####For MATLAB\r\n\r\n```matlab\r\n% lshbox_example2.m\r\n% prepare test data\r\ndataset = rand(128,500000);\r\ntestset = dataset(:,1:10);\r\n% Test itqlsh\r\nparam_itq.M = 521;\r\nparam_itq.L = 5;\r\nparam_itq.N = 8;\r\nparam_itq.S = 100;\r\nparam_itq.I = 50;\r\n% First time, need to constructing index. About 10s.\r\ntic;\r\n[indices, dists] = itqlsh(dataset, testset, param_itq, 'itq.lsh', 2, 10);\r\ntoc;\r\n% Second time, no need to re-indexing. About 2s.\r\ntic;\r\n[indices, dists] = itqlsh(dataset, testset, param_itq, 'itq.lsh', 2, 10);\r\ntoc;\r\n```\r\n\r\n###Chapter 4 - Algorithm\r\n\r\nLSHBOX is based on many approximate nearest neighbor schemes, and the following is a brief description of each algorithm and its parameters.\r\n\r\n\r\n####4.1 - Locality-Sensitive Hashing Scheme Based on Random Bits Sampling\r\n\r\n#####Reference\r\n\r\n```\r\nP. Indyk and R. Motwani. Approximate Nearest Neighbor - Towards Removing the Curse of Dimensionality. In Proceedings of the 30th Symposium on Theory of Computing, 1998, pp. 604-613.\r\n\r\nA. Gionis, P. Indyk, and R. Motwani. Similarity search in high dimensions via hashing. Proceedings of the 25th International Conference on Very Large Data Bases (VLDB), 1999.\r\n```\r\n\r\n#####Parameters\r\n\r\n```cpp\r\nstruct Parameter\r\n{\r\n\t/// Hash table size\r\n\tunsigned M;\r\n\t/// Number of hash tables\r\n\tunsigned L;\r\n\t/// Dimension of the vector\r\n\tunsigned D;\r\n\t/// Binary code bytes\r\n\tunsigned N;\r\n\t/// The Difference between upper and lower bound of each dimension\r\n\tunsigned C;\r\n};\r\n```\r\n\r\n#####Implementation\r\n\r\n```cpp\r\n#include <lshbox/rbslsh.h>\r\n```\r\n\r\nAccording to the second assumption in the paper, all coordinates of points in P are positive integer. Although we can convert all coordinates to integers by multiplying them by a suitably large number and rounding to the nearest integer, but I think it is very fussy, What's more, it often gets criticized for using too much memory when in a larger range of data. Therefore, it is recommended to use other algorithm.\r\n\r\n\r\n####4.2 - Locality-Sensitive Hashing Scheme Based on Random Hyperplane\r\n\r\n#####Reference\r\n\r\n```\r\nCharikar, M. S. 2002. Similarity estimation techniques from rounding algorithms. In Proceedings of the Thiry-Fourth Annual ACM Symposium on theory of Computing (Montreal, Quebec, Canada, May 19 - 21, 2002). STOC '02. ACM, New York, NY, 380-388. DOI= http://doi.acm.org/10.1145/509907.509965\r\n```\r\n\r\n#####Parameters\r\n\r\n```cpp\r\nstruct Parameter\r\n{\r\n\t/// Hash table size\r\n\tunsigned M;\r\n\t/// Number of hash tables\r\n\tunsigned L;\r\n\t/// Dimension of the vector\r\n\tunsigned D;\r\n\t/// Binary code bytes\r\n\tunsigned N;\r\n};\r\n```\r\n\r\n#####Implementation\r\n\r\n```cpp\r\n#include <lshbox/rhplsh.h>\r\n```\r\n\r\n####4.3 - Locality-Sensitive Hashing Scheme Based on Thresholding\r\n\r\n#####Reference\r\n\r\n```\r\nZhe Wang, Wei Dong, William Josephson, Qin Lv, Moses Charikar, Kai Li. Sizing Sketches: A Rank-Based Analysis for Similarity Search. In Proceedings of the 2007 ACM SIGMETRICS International Conference on Measurement and Modeling of Computer Systems . San Diego, CA, USA. June 2007.\r\n\r\nQin Lv, Moses Charikar, Kai Li. Image Similarity Search with Compact Data Structures. In Proceedings of ACM 13th Conference on Information and Knowledge Management (CIKM), Washington D.C., USA. November 2004.\r\n```\r\n\r\n#####Parameters\r\n\r\n```cpp\r\nstruct Parameter\r\n{\r\n\t/// Hash table size\r\n\tunsigned M;\r\n\t/// Number of hash tables\r\n\tunsigned L;\r\n\t/// Dimension of the vector\r\n\tunsigned D;\r\n\t/// Binary code bytes\r\n\tunsigned N;\r\n\t/// Upper bound of each dimension\r\n\tfloat Max;\r\n\t/// Lower bound of each dimension\r\n\tfloat Min;\r\n};\r\n```\r\n\r\n#####Implementation\r\n\r\n```cpp\r\n#include <lshbox/thlsh.h>\r\n```\r\n\r\n####4.4 - Locality-Sensitive Hashing Scheme Based on p-Stable Distributions\r\n\r\n#####Reference\r\n\r\n```\r\nMayur Datar , Nicole Immorlica , Piotr Indyk , Vahab S. Mirrokni, Locality-sensitive hashing scheme based on p-stable distributions, Proceedings of the twentieth annual symposium on Computational geometry, June 08-11, 2004, Brooklyn, New York, USA.\r\n```\r\n\r\n#####Parameters\r\n\r\n```cpp\r\nstruct Parameter\r\n{\r\n\t/// Hash table size\r\n\tunsigned M;\r\n\t/// Number of hash tables\r\n\tunsigned L;\r\n\t/// Dimension of the vector\r\n\tunsigned D;\r\n\t/// Index mode, you can choose 1(CAUCHY) or 2(GAUSSIAN)\r\n\tunsigned T;\r\n\t/// Window size\r\n\tfloat W;\r\n};\r\n```\r\n\r\n#####Implementation\r\n\r\n```cpp\r\n#include <lshbox/psdlsh.h>\r\n```\r\n\r\n####4.5 - Spectral Hashing\r\n\r\n#####Reference\r\n\r\n```\r\nY. Weiss, A. Torralba, R. Fergus. Spectral Hashing. Advances in Neural Information Processing Systems, 2008.\r\n```\r\n\r\n#####Parameters\r\n\r\n```cpp\r\nstruct Parameter\r\n{\r\n\t/// Hash table size\r\n\tunsigned M;\r\n\t/// Number of hash tables\r\n\tunsigned L;\r\n\t/// Dimension of the vector\r\n\tunsigned D;\r\n\t/// Binary code bytes\r\n\tunsigned N;\r\n\t/// Size of vectors in train\r\n\tunsigned S;\r\n};\r\n```\r\n\r\n#####Implementation\r\n\r\n```cpp\r\n#include <lshbox/shlsh.h>\r\n```\r\n\r\n####4.6 - Iterative Quantization\r\n\r\n#####Reference\r\n\r\n```\r\nGong Y, Lazebnik S, Gordo A, et al. Iterative quantization: A procrustean approach to learning binary codes for large-scale image retrieval[J]. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 2013, 35(12): 2916-2929.\r\n```\r\n\r\n#####Parameters\r\n\r\n```cpp\r\nstruct Parameter\r\n{\r\n\t/// Hash table size\r\n\tunsigned M;\r\n\t/// Number of hash tables\r\n\tunsigned L;\r\n\t/// Dimension of the vector\r\n\tunsigned D;\r\n\t/// Binary code bytes\r\n\tunsigned N;\r\n\t/// Size of vectors in train\r\n\tunsigned S;\r\n\t/// Training iterations\r\n\tunsigned I;\r\n};\r\n```\r\n\r\n#####Implementation\r\n\r\n```cpp\r\n#include <lshbox/itqlsh.h>\r\n```\r\n\r\nAccording to the test, Iterative Quantization performance very good and is superior to other schemes, it can get better query accuracy with minimum cost.","google":"lshbox, lsh","note":"Don't delete this file! It's used internally to help with page regeneration."}